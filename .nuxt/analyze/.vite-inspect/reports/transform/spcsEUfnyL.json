{
  "resolvedId": "/Users/kufre-abasibassey/Documents/Projects/WEB2/zentry clone/untitled folder/zentry/node_modules/gsap/utils/PathEditor.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*!\n * PathEditor 3.13.0\n * https://gsap.com\n *\n * Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nimport { stringToRawPath, rawPathToString, bezierToPoints, simplifyPoints, pointsToSegment, subdivideSegment, getClosestData, copyRawPath, transformRawPath } from \"./paths.js\";\nimport { getGlobalMatrix, Matrix2D } from \"./matrix.js\";\n\nvar _numbersExp = /(?:(-)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n    _doc,\n    _supportsPointer,\n    _win,\n    _body,\n    gsap,\n    _context,\n    _selectionColor = \"#4e7fff\",\n    _minimumMovement = 1,\n    _DEG2RAD = Math.PI / 180,\n    _getTime = Date.now || function () {\n  return new Date().getTime();\n},\n    _lastInteraction = 0,\n    _isPressed = 0,\n    _emptyFunc = function _emptyFunc() {\n  return false;\n},\n    _interacted = function _interacted() {\n  return _lastInteraction = _getTime();\n},\n    _CTRL,\n    _ALT,\n    _SHIFT,\n    _CMD,\n    _recentlyAddedAnchor,\n    _editingAxis = {},\n    //stores the x/y of the most recently-selected anchor point's x and y axis. We tap into this for snapping horizontally and vertically.\n_history = [],\n    _point = {},\n    //reuse to minimize memory and maximize performance (mostly for snapping)\n_temp = [],\n    //reuse this in places like getNormalizedSVG() to conserve memory\n_comma = \",\",\n    _selectedPaths = [],\n    _preventDefault = function _preventDefault(event) {\n  if (event.preventDefault) {\n    event.preventDefault();\n\n    if (event.preventManipulation) {\n      event.preventManipulation(); //for some Microsoft browsers\n    }\n  }\n},\n    _createElement = function _createElement(type) {\n  return _doc.createElementNS ? _doc.createElementNS(\"http://www.w3.org/1999/xhtml\", type) : _doc.createElement(type);\n},\n    _createSVG = function _createSVG(type, container, attributes) {\n  var element = _doc.createElementNS(\"http://www.w3.org/2000/svg\", type),\n      reg = /([a-z])([A-Z])/g,\n      p;\n\n  attributes = attributes || {};\n  attributes[\"class\"] = attributes[\"class\"] || \"path-editor\";\n\n  for (p in attributes) {\n    if (element.style[p] !== undefined) {\n      element.style[p] = attributes[p];\n    } else {\n      element.setAttributeNS(null, p.replace(reg, \"$1-$2\").toLowerCase(), attributes[p]);\n    }\n  }\n\n  container.appendChild(element);\n  return element;\n},\n    _identityMatrixObject = {\n  matrix: new Matrix2D()\n},\n    _getConsolidatedMatrix = function _getConsolidatedMatrix(target) {\n  return (target.transform && target.transform.baseVal.consolidate() || _identityMatrixObject).matrix;\n},\n    _getConcatenatedTransforms = function _getConcatenatedTransforms(target) {\n  var m = _getConsolidatedMatrix(target),\n      owner = target.ownerSVGElement;\n\n  while ((target = target.parentNode) && target.ownerSVGElement === owner) {\n    m.multiply(_getConsolidatedMatrix(target));\n  }\n\n  return \"matrix(\" + m.a + \",\" + m.b + \",\" + m.c + \",\" + m.d + \",\" + m.e + \",\" + m.f + \")\";\n},\n    _addHistory = function _addHistory(pathEditor) {\n  var selectedIndexes = [],\n      a = pathEditor._selectedAnchors,\n      i;\n\n  for (i = 0; i < a.length; i++) {\n    selectedIndexes[i] = a[i].i;\n  }\n\n  _history.unshift({\n    path: pathEditor,\n    d: pathEditor.path.getAttribute(\"d\"),\n    transform: pathEditor.path.getAttribute(\"transform\") || \"\",\n    selectedIndexes: selectedIndexes\n  });\n\n  if (_history.length > 30) {\n    _history.length = 30;\n  }\n},\n    _round = function _round(value) {\n  return ~~(value * 1000 + (value < 0 ? -.5 : .5)) / 1000;\n},\n    _getSquarePathData = function _getSquarePathData(size) {\n  size = _round(size);\n  return [\"M-\" + size, -size, size, -size, size, size, -size, size + \"z\"].join(_comma);\n},\n    _getCirclePathData = function _getCirclePathData(size) {\n  var circ = 0.552284749831,\n      rcirc = _round(size * circ);\n\n  size = _round(size);\n  return \"M\" + size + \",0C\" + [size, rcirc, rcirc, size, 0, size, -rcirc, size, -size, rcirc, -size, 0, -size, -rcirc, -rcirc, -size, 0, -size, rcirc, -size, size, -rcirc, size, 0].join(_comma) + \"z\";\n},\n    _checkDeselect = function _checkDeselect(e) {\n  if (!e.target._gsSelection && !_isPressed && _getTime() - _lastInteraction > 100) {\n    var i = _selectedPaths.length;\n\n    while (--i > -1) {\n      _selectedPaths[i].deselect();\n    }\n\n    _selectedPaths.length = 0;\n  }\n},\n    _tempDiv,\n    _touchEventLookup,\n    _isMultiTouching = 0,\n    _addListener = function _addListener(element, type, func, capture) {\n  if (element.addEventListener) {\n    var touchType = _touchEventLookup[type];\n    capture = capture || {\n      passive: false\n    };\n    element.addEventListener(touchType || type, func, capture);\n\n    if (touchType && type !== touchType && touchType.substr(0, 7) !== \"pointer\") {\n      //some browsers actually support both, so must we. But pointer events cover all.\n      element.addEventListener(type, func, capture);\n    }\n  } else if (element.attachEvent) {\n    element.attachEvent(\"on\" + type, func);\n  }\n},\n    _removeListener = function _removeListener(element, type, func) {\n  if (element.removeEventListener) {\n    var touchType = _touchEventLookup[type];\n    element.removeEventListener(touchType || type, func);\n\n    if (touchType && type !== touchType && touchType.substr(0, 7) !== \"pointer\") {\n      element.removeEventListener(type, func);\n    }\n  } else if (element.detachEvent) {\n    element.detachEvent(\"on\" + type, func);\n  }\n},\n    _hasTouchID = function _hasTouchID(list, ID) {\n  var i = list.length;\n\n  while (--i > -1) {\n    if (list[i].identifier === ID) {\n      return true;\n    }\n  }\n\n  return false;\n},\n    _onMultiTouchDocumentEnd = function _onMultiTouchDocumentEnd(e) {\n  _isMultiTouching = e.touches && _dragCount < e.touches.length;\n\n  _removeListener(e.target, \"touchend\", _onMultiTouchDocumentEnd);\n},\n    _onMultiTouchDocument = function _onMultiTouchDocument(e) {\n  _isMultiTouching = e.touches && _dragCount < e.touches.length;\n\n  _addListener(e.target, \"touchend\", _onMultiTouchDocumentEnd);\n},\n    _bind = function _bind(func, scope) {\n  return function (e) {\n    return func.call(scope, e);\n  };\n},\n    _callback = function _callback(type, self, param) {\n  var callback = self.vars[type];\n\n  if (callback) {\n    callback.call(self.vars.callbackScope || self, param || self);\n  }\n\n  return self;\n},\n    _copyElement,\n    _resetSelection = function _resetSelection() {\n  _copyElement.style.display = \"block\";\n\n  _copyElement.select();\n\n  _copyElement.style.display = \"none\";\n},\n    _coreInitted,\n    _initCore = function _initCore(core) {\n  _doc = document;\n  _win = window;\n  _body = _doc.body;\n  gsap = gsap || core || _win.gsap || console.warn(\"Please gsap.registerPlugin(PathEditor)\");\n\n  _context = gsap && gsap.core.context || function () {};\n\n  _tempDiv = _createElement(\"div\");\n  _copyElement = _createElement(\"textarea\");\n  _copyElement.style.display = \"none\";\n  _body && _body.appendChild(_copyElement);\n\n  _touchEventLookup = function (types) {\n    //we create an object that makes it easy to translate touch event types into their \"pointer\" counterparts if we're in a browser that uses those instead. Like IE10 uses \"MSPointerDown\" instead of \"touchstart\", for example.\n    var standard = types.split(\",\"),\n        converted = (_tempDiv.onpointerdown !== undefined ? \"pointerdown,pointermove,pointerup,pointercancel\" : _tempDiv.onmspointerdown !== undefined ? \"MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel\" : types).split(\",\"),\n        obj = {},\n        i = 4;\n\n    while (--i > -1) {\n      obj[standard[i]] = converted[i];\n      obj[converted[i]] = standard[i];\n    }\n\n    return obj;\n  }(\"touchstart,touchmove,touchend,touchcancel\");\n\n  SVGElement.prototype.getTransformToElement = SVGElement.prototype.getTransformToElement || function (e) {\n    //adds Chrome support\n    return e.getScreenCTM().inverse().multiply(this.getScreenCTM());\n  };\n\n  _doc.addEventListener(\"keydown\", function (e) {\n    var key = e.keyCode || e.which,\n        keyString = e.key || key,\n        i,\n        state,\n        a,\n        path;\n\n    if (keyString === \"Shift\" || key === 16) {\n      _SHIFT = true;\n    } else if (keyString === \"Control\" || key === 17) {\n      _CTRL = true;\n    } else if (keyString === \"Meta\" || key === 91) {\n      _CMD = true;\n    } else if (keyString === \"Alt\" || key === 18) {\n      _ALT = true;\n      i = _selectedPaths.length;\n\n      while (--i > -1) {\n        _selectedPaths[i]._onPressAlt();\n      }\n    } else if ((keyString === \"z\" || key === 90) && (_CTRL || _CMD) && _history.length > 1) {\n      //UNDO\n      _history.shift();\n\n      state = _history[0];\n\n      if (state) {\n        path = state.path;\n        path.path.setAttribute(\"d\", state.d);\n        path.path.setAttribute(\"transform\", state.transform);\n        path.init();\n        a = path._anchors;\n\n        for (i = 0; i < a.length; i++) {\n          if (state.selectedIndexes.indexOf(a[i].i) !== -1) {\n            path._selectedAnchors.push(a[i]);\n          }\n        }\n\n        path._updateAnchors();\n\n        path.update();\n\n        if (path.vars.onUndo) {\n          path.vars.onUndo.call(path);\n        }\n      }\n    } else if (keyString === \"Delete\" || keyString === \"Backspace\" || key === 8 || key === 46 || key === 63272 || key === \"d\" && (_CTRL || _CMD)) {\n      //DELETE\n      i = _selectedPaths.length;\n\n      while (--i > -1) {\n        _selectedPaths[i]._deleteSelectedAnchors();\n      }\n    } else if ((keyString === \"a\" || key === 65) && (_CMD || _CTRL)) {\n      //SELECT ALL\n      i = _selectedPaths.length;\n\n      while (--i > -1) {\n        _selectedPaths[i].select(true);\n      }\n    }\n  }, true);\n\n  _doc.addEventListener(\"keyup\", function (e) {\n    var key = e.key || e.keyCode || e.which;\n\n    if (key === \"Shift\" || key === 16) {\n      _SHIFT = false;\n    } else if (key === \"Control\" || key === 17) {\n      _CTRL = false;\n    } else if (key === \"Meta\" || key === 91) {\n      _CMD = false;\n    } else if (key === \"Alt\" || key === 18) {\n      _ALT = false;\n      var i = _selectedPaths.length;\n\n      while (--i > -1) {\n        _selectedPaths[i]._onReleaseAlt();\n      }\n    }\n  }, true);\n\n  _supportsPointer = !!_win.PointerEvent;\n\n  _addListener(_doc, \"mouseup\", _checkDeselect);\n\n  _addListener(_doc, \"touchend\", _checkDeselect);\n\n  _addListener(_doc, \"touchcancel\", _emptyFunc); //some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document. Very strange indeed.\n\n\n  _addListener(_win, \"touchmove\", _emptyFunc); //works around Safari bugs that still allow the page to scroll even when we preventDefault() on the touchmove event.\n\n\n  _body && _body.addEventListener(\"touchstart\", _emptyFunc); //works around Safari bug: https://gsap.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n\n  _coreInitted = 1;\n},\n    _onPress = function _onPress(e) {\n  var self = this,\n      ctm = getGlobalMatrix(self.target.parentNode, true),\n      //previously used self.target.parentNode.getScreenCTM().inverse() but there's a major bug in Firefox that prevents it from working properly when there's an ancestor with a transform applied, so we bootstrapped our own solution that seems to work great across all browsers.\n  touchEventTarget,\n      temp;\n  this._matrix = this.target.transform.baseVal.getItem(0).matrix;\n  this._ctm = ctm;\n\n  if (_touchEventLookup[e.type]) {\n    //note: on iOS, BOTH touchmove and mousemove are dispatched, but the mousemove has pageY and pageX of 0 which would mess up the calculations and needlessly hurt performance.\n    touchEventTarget = e.type.indexOf(\"touch\") !== -1 ? e.currentTarget || e.target : _doc; //pointer-based touches (for Microsoft browsers) don't remain locked to the original target like other browsers, so we must use the document instead. The event type would be \"MSPointerDown\" or \"pointerdown\".\n\n    _addListener(touchEventTarget, \"touchend\", self._onRelease);\n\n    _addListener(touchEventTarget, \"touchmove\", self._onMove);\n\n    _addListener(touchEventTarget, \"touchcancel\", self._onRelease);\n\n    _addListener(_doc, \"touchstart\", _onMultiTouchDocument);\n\n    _addListener(_win, \"touchforcechange\", _preventDefault); //otherwise iOS will scroll when dragging.\n\n  } else {\n    touchEventTarget = null;\n\n    _addListener(_doc, \"mousemove\", self._onMove); //attach these to the document instead of the box itself so that if the user's mouse moves too quickly (and off of the box), things still work.\n\n  }\n\n  if (!_supportsPointer) {\n    _addListener(_doc, \"mouseup\", self._onRelease);\n  }\n\n  _preventDefault(e);\n\n  _resetSelection(); // when a PathEditor is in an iframe in an environment like codepen, this helps avoid situations where the DELETE key won't actually work because the parent frame is intercepting the event.\n\n\n  if (e.changedTouches) {\n    //touch events store the data slightly differently\n    e = self.touch = e.changedTouches[0];\n    self.touchID = e.identifier;\n  } else if (e.pointerId) {\n    self.touchID = e.pointerId; //for some Microsoft browsers\n  } else {\n    self.touch = self.touchID = null;\n  }\n\n  self._startPointerY = self.pointerY = e.pageY; //record the starting x and y so that we can calculate the movement from the original in _onMouseMove\n\n  self._startPointerX = self.pointerX = e.pageX;\n  self._startElementX = self._matrix.e;\n  self._startElementY = self._matrix.f;\n\n  if (this._ctm.a === 1 && this._ctm.b === 0 && this._ctm.c === 0 && this._ctm.d === 1) {\n    this._ctm = null;\n  } else {\n    temp = self._startPointerX * this._ctm.a + self._startPointerY * this._ctm.c + this._ctm.e;\n    self._startPointerY = self._startPointerX * this._ctm.b + self._startPointerY * this._ctm.d + this._ctm.f;\n    self._startPointerX = temp;\n  }\n\n  self.isPressed = _isPressed = true;\n  self.touchEventTarget = touchEventTarget;\n\n  if (self.vars.onPress) {\n    self.vars.onPress.call(self.vars.callbackScope || self, self.pointerEvent);\n  }\n},\n    _onMove = function _onMove(e) {\n  var self = this,\n      originalEvent = e,\n      touches,\n      i;\n\n  if (!self._enabled || _isMultiTouching || !self.isPressed || !e) {\n    return;\n  }\n\n  self.pointerEvent = e;\n  touches = e.changedTouches;\n\n  if (touches) {\n    //touch events store the data slightly differently\n    e = touches[0];\n\n    if (e !== self.touch && e.identifier !== self.touchID) {\n      //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)\n      i = touches.length;\n\n      while (--i > -1 && (e = touches[i]).identifier !== self.touchID) {}\n\n      if (i < 0) {\n        return;\n      }\n    }\n  } else if (e.pointerId && self.touchID && e.pointerId !== self.touchID) {\n    //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)\n    return;\n  }\n\n  _preventDefault(originalEvent);\n\n  self.setPointerPosition(e.pageX, e.pageY);\n\n  if (self.vars.onDrag) {\n    self.vars.onDrag.call(self.vars.callbackScope || self, self.pointerEvent);\n  }\n},\n    _onRelease = function _onRelease(e, force) {\n  var self = this;\n\n  if (!self._enabled || !self.isPressed || e && self.touchID != null && !force && (e.pointerId && e.pointerId !== self.touchID || e.changedTouches && !_hasTouchID(e.changedTouches, self.touchID))) {\n    //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)\n    return;\n  }\n\n  _interacted();\n\n  self.isPressed = _isPressed = false; //TODO: if we want to accommodate multi-touch, we'd need to introduce a counter to track how many touches there are and only toggle this when they're all off.\n\n  var originalEvent = e,\n      wasDragging = self.isDragging,\n      touchEventTarget = self.touchEventTarget,\n      touches,\n      i;\n\n  if (touchEventTarget) {\n    _removeListener(touchEventTarget, \"touchend\", self._onRelease);\n\n    _removeListener(touchEventTarget, \"touchmove\", self._onMove);\n\n    _removeListener(touchEventTarget, \"touchcancel\", self._onRelease);\n\n    _removeListener(_doc, \"touchstart\", _onMultiTouchDocument);\n  } else {\n    _removeListener(_doc, \"mousemove\", self._onMove);\n  }\n\n  if (!_supportsPointer) {\n    _removeListener(_doc, \"mouseup\", self._onRelease);\n\n    if (e && e.target) {\n      _removeListener(e.target, \"mouseup\", self._onRelease);\n    }\n  }\n\n  if (wasDragging) {\n    self.isDragging = false;\n  } else if (self.vars.onClick) {\n    self.vars.onClick.call(self.vars.callbackScope || self, originalEvent);\n  }\n\n  if (e) {\n    touches = e.changedTouches;\n\n    if (touches) {\n      //touch events store the data slightly differently\n      e = touches[0];\n\n      if (e !== self.touch && e.identifier !== self.touchID) {\n        //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)\n        i = touches.length;\n\n        while (--i > -1 && (e = touches[i]).identifier !== self.touchID) {}\n\n        if (i < 0) {\n          return;\n        }\n      }\n    }\n\n    self.pointerEvent = originalEvent;\n    self.pointerX = e.pageX;\n    self.pointerY = e.pageY;\n  }\n\n  if (originalEvent && !wasDragging && self.vars.onDragRelease) {\n    self.vars.onDragRelease.call(self, self.pointerEvent);\n  } else {\n    if (originalEvent) {\n      _preventDefault(originalEvent);\n    }\n\n    if (self.vars.onRelease) {\n      self.vars.onRelease.call(self.vars.callbackScope || self, self.pointerEvent);\n    }\n  }\n\n  if (wasDragging && self.vars.onDragEnd) {\n    self.vars.onDragEnd.call(self.vars.callbackScope || self, self.pointerEvent);\n  }\n\n  return true;\n},\n    _createSegmentAnchors = function _createSegmentAnchors(rawPath, j, editor, vars) {\n  var segment = rawPath[j],\n      l = segment.length - (segment.closed ? 6 : 0),\n      a = [],\n      i;\n\n  for (i = 0; i < l; i += 6) {\n    a.push(new Anchor(editor, rawPath, j, i, vars));\n  }\n\n  segment.closed && (a[0].isClosedStart = true);\n  return a;\n},\n    _getLength = function _getLength(segment, i, i2) {\n  //i is the starting index, and it'll return the length to the next x/y pair. So if you're looking for the length to handle1, you'd feed in the index of the handle control point x whereas if you're looking for the length to handle2, i would be the x of the anchor.\n  var x = segment[i2] - segment[i],\n      y = segment[i2 + 1] - segment[i + 1];\n  return Math.sqrt(x * x + y * y);\n};\n\nvar DraggableSVG = /*#__PURE__*/function () {\n  function DraggableSVG(target, vars) {\n    this.target = typeof target === \"string\" ? _doc.querySelectorAll(target)[0] : target;\n    this.vars = vars || {};\n    this._onPress = _bind(_onPress, this);\n    this._onMove = _bind(_onMove, this);\n    this._onRelease = _bind(_onRelease, this);\n    this.target.setAttribute(\"transform\", (this.target.getAttribute(\"transform\") || \"\") + \" translate(0,0)\");\n    this._matrix = _getConsolidatedMatrix(this.target);\n    this.x = this._matrix.e;\n    this.y = this._matrix.f;\n    this.snap = vars.snap;\n\n    if (!isNaN(vars.maxX) || !isNaN(vars.minX)) {\n      this._bounds = 1;\n      this.maxX = +vars.maxX;\n      this.minX = +vars.minX;\n    } else {\n      this._bounds = 0;\n    }\n\n    this.enabled(true);\n  }\n\n  var _proto = DraggableSVG.prototype;\n\n  _proto.setPointerPosition = function setPointerPosition(pointerX, pointerY) {\n    var rnd = 1000,\n        xChange,\n        yChange,\n        x,\n        y,\n        temp;\n    this.pointerX = pointerX;\n    this.pointerY = pointerY;\n\n    if (this._ctm) {\n      temp = pointerX * this._ctm.a + pointerY * this._ctm.c + this._ctm.e;\n      pointerY = pointerX * this._ctm.b + pointerY * this._ctm.d + this._ctm.f;\n      pointerX = temp;\n    }\n\n    yChange = pointerY - this._startPointerY;\n    xChange = pointerX - this._startPointerX;\n\n    if (yChange < _minimumMovement && yChange > -_minimumMovement) {\n      yChange = 0;\n    }\n\n    if (xChange < _minimumMovement && xChange > -_minimumMovement) {\n      xChange = 0;\n    }\n\n    x = ((this._startElementX + xChange) * rnd | 0) / rnd;\n    y = ((this._startElementY + yChange) * rnd | 0) / rnd;\n\n    if (this.snap && !_SHIFT) {\n      _point.x = x;\n      _point.y = y;\n      this.snap.call(this, _point);\n      x = _point.x;\n      y = _point.y;\n    }\n\n    if (this.x !== x || this.y !== y) {\n      this._matrix.f = this.y = y;\n      this._matrix.e = this.x = x;\n\n      if (!this.isDragging && this.isPressed) {\n        this.isDragging = true;\n\n        _callback(\"onDragStart\", this, this.pointerEvent);\n      }\n    }\n  };\n\n  _proto.enabled = function enabled(_enabled) {\n    if (!arguments.length) {\n      return this._enabled;\n    }\n\n    var dragging;\n    this._enabled = _enabled;\n\n    if (_enabled) {\n      if (!_supportsPointer) {\n        _addListener(this.target, \"mousedown\", this._onPress);\n      }\n\n      _addListener(this.target, \"touchstart\", this._onPress);\n\n      _addListener(this.target, \"click\", this._onClick, true); //note: used to pass true for capture but it prevented click-to-play-video functionality in Firefox.\n\n    } else {\n      dragging = this.isDragging;\n\n      _removeListener(this.target, \"mousedown\", this._onPress);\n\n      _removeListener(this.target, \"touchstart\", this._onPress);\n\n      _removeListener(_win, \"touchforcechange\", _preventDefault);\n\n      _removeListener(this.target, \"click\", this._onClick);\n\n      if (this.touchEventTarget) {\n        _removeListener(this.touchEventTarget, \"touchcancel\", this._onRelease);\n\n        _removeListener(this.touchEventTarget, \"touchend\", this._onRelease);\n\n        _removeListener(this.touchEventTarget, \"touchmove\", this._onMove);\n      }\n\n      _removeListener(_doc, \"mouseup\", this._onRelease);\n\n      _removeListener(_doc, \"mousemove\", this._onMove);\n\n      this.isDragging = this.isPressed = false;\n\n      if (dragging) {\n        _callback(\"onDragEnd\", this, this.pointerEvent);\n      }\n    }\n\n    return this;\n  };\n\n  _proto.endDrag = function endDrag(e) {\n    this._onRelease(e);\n  };\n\n  return DraggableSVG;\n}();\n\nvar Anchor = /*#__PURE__*/function () {\n  function Anchor(editor, rawPath, j, i, vars) {\n    this.editor = editor;\n    this.element = _createSVG(\"path\", editor._selection, {\n      fill: _selectionColor,\n      stroke: _selectionColor,\n      strokeWidth: 2,\n      vectorEffect: \"non-scaling-stroke\"\n    });\n    this.update(rawPath, j, i);\n    this.element._gsSelection = true;\n    this.vars = vars || {};\n    this._draggable = new DraggableSVG(this.element, {\n      callbackScope: this,\n      onDrag: this.onDrag,\n      snap: this.vars.snap,\n      onPress: this.onPress,\n      onRelease: this.onRelease,\n      onClick: this.onClick,\n      onDragEnd: this.onDragEnd\n    });\n  }\n\n  var _proto2 = Anchor.prototype;\n\n  _proto2.onPress = function onPress() {\n    _callback(\"onPress\", this);\n  };\n\n  _proto2.onClick = function onClick() {\n    _callback(\"onClick\", this);\n  };\n\n  _proto2.onDrag = function onDrag() {\n    var s = this.segment;\n    this.vars.onDrag.call(this.vars.callbackScope || this, this, this._draggable.x - s[this.i], this._draggable.y - s[this.i + 1]);\n  };\n\n  _proto2.onDragEnd = function onDragEnd() {\n    _callback(\"onDragEnd\", this);\n  };\n\n  _proto2.onRelease = function onRelease() {\n    _callback(\"onRelease\", this);\n  };\n\n  _proto2.update = function update(rawPath, j, i) {\n    if (rawPath) {\n      this.rawPath = rawPath;\n    }\n\n    if (arguments.length <= 1) {\n      j = this.j;\n      i = this.i;\n    } else {\n      this.j = j;\n      this.i = i;\n    }\n\n    var prevSmooth = this.smooth,\n        segment = this.rawPath[j],\n        pi = i === 0 && segment.closed ? segment.length - 4 : i - 2;\n    this.segment = segment;\n    this.smooth = i > 0 && i < segment.length - 2 && Math.abs(Math.atan2(segment[i + 1] - segment[pi + 1], segment[i] - segment[pi]) - Math.atan2(segment[i + 3] - segment[i + 1], segment[i + 2] - segment[i])) < 0.09 ? 2 : 0; //0: corner, 1: smooth but not mirrored, 2: smooth and mirrored.\n\n    if (this.smooth !== prevSmooth) {\n      this.element.setAttribute(\"d\", this.smooth ? this.editor._circleHandle : this.editor._squareHandle);\n    }\n\n    this.element.setAttribute(\"transform\", \"translate(\" + segment[i] + \",\" + segment[i + 1] + \")\");\n  };\n\n  return Anchor;\n}();\n\nexport var PathEditor = /*#__PURE__*/function () {\n  function PathEditor(target, vars) {\n    vars = vars || {};\n    _coreInitted || _initCore();\n    this.vars = vars;\n    this.path = typeof target === \"string\" ? _doc.querySelectorAll(target)[0] : target;\n    this._g = _createSVG(\"g\", this.path.ownerSVGElement, {\n      \"class\": \"path-editor-g path-editor\"\n    });\n    this._selectionHittest = _createSVG(\"path\", this._g, {\n      stroke: \"transparent\",\n      strokeWidth: 16,\n      fill: \"none\",\n      vectorEffect: \"non-scaling-stroke\"\n    });\n    this._selection = vars._selection || _createSVG(\"g\", this._g, {\n      \"class\": \"path-editor-selection path-editor\"\n    });\n    this._selectionPath = _createSVG(\"path\", this._selection, {\n      stroke: _selectionColor,\n      strokeWidth: 2,\n      fill: \"none\",\n      vectorEffect: \"non-scaling-stroke\"\n    });\n    this._selectedAnchors = [];\n    this._line1 = _createSVG(\"polyline\", this._selection, {\n      stroke: _selectionColor,\n      strokeWidth: 2,\n      vectorEffect: \"non-scaling-stroke\"\n    });\n    this._line2 = _createSVG(\"polyline\", this._selection, {\n      stroke: _selectionColor,\n      strokeWidth: 2,\n      vectorEffect: \"non-scaling-stroke\"\n    });\n    this._line1.style.pointerEvents = this._line2.style.pointerEvents = this._selectionPath.style.pointerEvents = \"none\";\n    this._enabled = true;\n    var ctm = this.path.parentNode.getScreenCTM().inverse(),\n        size = (ctm.a + ctm.d) / 2 * (vars.handleSize || 5);\n    this._squareHandle = _getSquarePathData(size);\n    this._circleHandle = _getCirclePathData(size * 1.15);\n    this._handle1 = _createSVG(\"path\", this._selection, {\n      d: this._squareHandle,\n      fill: _selectionColor,\n      stroke: \"transparent\",\n      strokeWidth: 6\n    });\n    this._handle2 = _createSVG(\"path\", this._selection, {\n      d: this._squareHandle,\n      fill: _selectionColor,\n      stroke: \"transparent\",\n      strokeWidth: 6\n    });\n    this._handle1._draggable = new DraggableSVG(this._handle1, {\n      onDrag: this._onDragHandle1,\n      callbackScope: this,\n      onPress: this._onPressHandle1,\n      onRelease: this._onReleaseHandle,\n      onClick: this._onClickHandle1,\n      snap: vars.handleSnap\n    });\n    this._handle2._draggable = new DraggableSVG(this._handle2, {\n      onDrag: this._onDragHandle2,\n      callbackScope: this,\n      onPress: this._onPressHandle2,\n      onRelease: this._onReleaseHandle,\n      onClick: this._onClickHandle2,\n      snap: vars.handleSnap\n    });\n    this._handle1.style.visibility = this._handle2.style.visibility = \"hidden\";\n    var selectionItems = [this._handle1, this._handle2, this._line1, this._line2, this._selection, this._selectionPath, this._selectionHittest],\n        i = selectionItems.length;\n\n    while (--i > -1) {\n      selectionItems[i]._gsSelection = true; //just a flag we can check in the _checkDeselect() method to detect clicks on things that are selection-related.\n    }\n\n    if (vars.draggable !== false) {\n      this._draggable = new DraggableSVG(this._selectionHittest, {\n        callbackScope: this,\n        onPress: this.select,\n        onRelease: this._onRelease,\n        onDrag: this._onDragPath,\n        onDragEnd: this._saveState,\n        maxX: this.vars.maxX,\n        minX: this.vars.minX\n      });\n    }\n\n    this.init();\n    this._selection.style.visibility = vars.selected === false ? \"hidden\" : \"visible\";\n\n    if (vars.selected !== false) {\n      this.path._gsSelection = true;\n\n      _selectedPaths.push(this);\n    }\n\n    this._saveState();\n\n    if (!_supportsPointer) {\n      _addListener(this._selectionHittest, \"mousedown\", _bind(this._onClickSelectionPath, this));\n\n      _addListener(this._selectionHittest, \"mouseup\", _bind(this._onRelease, this));\n    }\n\n    _addListener(this._selectionHittest, \"touchstart\", _bind(this._onClickSelectionPath, this));\n\n    _addListener(this._selectionHittest, \"touchend\", _bind(this._onRelease, this));\n\n    _context(this);\n  }\n\n  var _proto3 = PathEditor.prototype;\n\n  _proto3._onRelease = function _onRelease(e) {\n    var anchor = this._editingAnchor;\n\n    if (anchor) {\n      _editingAxis.x = anchor.segment[anchor.i];\n      _editingAxis.y = anchor.segment[anchor.i + 1];\n    }\n\n    _removeListener(_win, \"touchforcechange\", _preventDefault); //otherwise iOS will scroll when dragging.\n\n\n    _callback(\"onRelease\", this, e);\n  };\n\n  _proto3.init = function init() {\n    var pathData = this.path.getAttribute(\"d\"),\n        rawPath = stringToRawPath(pathData),\n        transform = this.path.getAttribute(\"transform\") || \"translate(0,0)\",\n        createAnchors = !this._rawPath || rawPath.totalPoints !== this._rawPath.totalPoints || rawPath.length !== this._rawPath.length,\n        anchorVars = {\n      callbackScope: this,\n      snap: this.vars.anchorSnap,\n      onDrag: this._onDragAnchor,\n      onPress: this._onPressAnchor,\n      onRelease: this._onRelease,\n      onClick: this._onClickAnchor,\n      onDragEnd: this._onDragEndAnchor,\n      maxX: this.vars.maxX,\n      minX: this.vars.minX\n    },\n        l,\n        i;\n\n    if (createAnchors && this._anchors && this._anchors.length) {\n      for (i = 0; i < this._anchors.length; i++) {\n        this._anchors[i].element.parentNode.removeChild(this._anchors[i].element);\n\n        this._anchors[i]._draggable.enabled(false);\n      }\n\n      this._selectedAnchors.length = 0;\n    }\n\n    this._rawPath = rawPath;\n\n    if (createAnchors) {\n      this._anchors = _createSegmentAnchors(rawPath, 0, this, anchorVars);\n      l = rawPath.length;\n\n      if (l > 1) {\n        for (i = 1; i < l; i++) {\n          this._anchors = this._anchors.concat(_createSegmentAnchors(rawPath, i, this, anchorVars));\n        }\n      }\n    } else {\n      i = this._anchors.length;\n\n      while (--i > -1) {\n        this._anchors[i].update(rawPath);\n      }\n    }\n\n    this._selection.appendChild(this._handle1); //for stacking order (handles should always be on top)\n\n\n    this._selection.appendChild(this._handle2); //\t\tthis._selectedAnchors.length = 0;\n\n\n    this._selectionPath.setAttribute(\"d\", pathData);\n\n    this._selectionHittest.setAttribute(\"d\", pathData);\n\n    this._g.setAttribute(\"transform\", _getConcatenatedTransforms(this.path.parentNode) || \"translate(0,0)\");\n\n    this._selection.setAttribute(\"transform\", transform);\n\n    this._selectionHittest.setAttribute(\"transform\", transform);\n\n    this._updateAnchors();\n\n    return this;\n  };\n\n  _proto3._saveState = function _saveState() {\n    _addHistory(this);\n  };\n\n  _proto3._onClickSelectionPath = function _onClickSelectionPath(e) {\n    if (this._selection.style.visibility === \"hidden\") {\n      this.select();\n    } else if (_ALT || e && e.altKey) {\n      var anchorVars = {\n        callbackScope: this,\n        snap: this.vars.anchorSnap,\n        onDrag: this._onDragAnchor,\n        onPress: this._onPressAnchor,\n        onRelease: this._onRelease,\n        onClick: this._onClickAnchor,\n        onDragEnd: this._onDragEndAnchor,\n        maxX: this.vars.maxX,\n        minX: this.vars.minX\n      },\n          ctm = this._selection.getScreenCTM().inverse(),\n          newIndex,\n          _i,\n          anchor,\n          x,\n          y,\n          closestData;\n\n      if (this._draggable) {\n        this._draggable._onRelease(e); //otherwise, ALT-click/dragging on a path would create a new anchor AND drag the entire path.\n\n      }\n\n      if (ctm) {\n        x = e.clientX * ctm.a + e.clientY * ctm.c + ctm.e;\n        y = e.clientX * ctm.b + e.clientY * ctm.d + ctm.f;\n      } //DEBUG: _createSVG(\"circle\", this._selection, {fill:\"red\", r:5, cx:x, cy:y});\n\n\n      closestData = getClosestData(this._rawPath, x, y);\n      subdivideSegment(this._rawPath[closestData.j], closestData.i, closestData.t);\n      newIndex = closestData.i + 6;\n\n      for (_i = 0; _i < this._anchors.length; _i++) {\n        if (this._anchors[_i].i >= newIndex && this._anchors[_i].j === closestData.j) {\n          this._anchors[_i].i += 6;\n        }\n      }\n\n      anchor = new Anchor(this, this._rawPath, closestData.j, newIndex, anchorVars);\n\n      this._selection.appendChild(this._handle1); //for stacking order (handles should always be on top)\n\n\n      this._selection.appendChild(this._handle2);\n\n      anchor._draggable._onPress(e);\n\n      _recentlyAddedAnchor = anchor;\n\n      this._anchors.push(anchor);\n\n      this._selectedAnchors.length = 0;\n\n      this._selectedAnchors.push(anchor);\n\n      this._updateAnchors();\n\n      this.update();\n\n      this._saveState();\n    }\n\n    _resetSelection();\n\n    _addListener(_win, \"touchforcechange\", _preventDefault); //otherwise iOS will scroll when dragging.\n\n\n    _callback(\"onPress\", this);\n  };\n\n  _proto3._onClickHandle1 = function _onClickHandle1() {\n    var anchor = this._editingAnchor,\n        i = anchor.i,\n        s = anchor.segment,\n        pi = anchor.isClosedStart ? s.length - 4 : i - 2;\n\n    if (_ALT && Math.abs(s[i] - s[pi]) < 5 && Math.abs(s[i + 1] - s[pi + 1]) < 5) {\n      this._onClickAnchor(anchor);\n    }\n  };\n\n  _proto3._onClickHandle2 = function _onClickHandle2() {\n    var anchor = this._editingAnchor,\n        i = anchor.i,\n        s = anchor.segment;\n\n    if (_ALT && Math.abs(s[i] - s[i + 2]) < 5 && Math.abs(s[i + 1] - s[i + 3]) < 5) {\n      this._onClickAnchor(anchor);\n    }\n  };\n\n  _proto3._onDragEndAnchor = function _onDragEndAnchor(e) {\n    _recentlyAddedAnchor = null;\n\n    this._saveState();\n  };\n\n  _proto3.isSelected = function isSelected() {\n    return this._selectedAnchors.length > 0 || this._selection.style.visibility === \"visible\";\n  };\n\n  _proto3.select = function select(allAnchors) {\n    this._selection.style.visibility = \"visible\";\n    this._editingAnchor = null;\n    this.path._gsSelection = true;\n\n    if (allAnchors === true) {\n      var _i2 = this._anchors.length;\n\n      while (--_i2 > -1) {\n        this._selectedAnchors[_i2] = this._anchors[_i2];\n      }\n    }\n\n    if (_selectedPaths.indexOf(this) === -1) {\n      _selectedPaths.push(this);\n    }\n\n    this._updateAnchors();\n\n    return this;\n  };\n\n  _proto3.deselect = function deselect() {\n    this._selection.style.visibility = \"hidden\";\n    this._selectedAnchors.length = 0;\n    this._editingAnchor = null;\n    this.path._gsSelection = false;\n\n    _selectedPaths.splice(_selectedPaths.indexOf(this), 1);\n\n    this._updateAnchors();\n\n    return this;\n  };\n\n  _proto3._onDragPath = function _onDragPath(e) {\n    var transform = this._selectionHittest.getAttribute(\"transform\") || \"translate(0,0)\";\n\n    this._selection.setAttribute(\"transform\", transform);\n\n    this.path.setAttribute(\"transform\", transform);\n  };\n\n  _proto3._onPressAnchor = function _onPressAnchor(anchor) {\n    if (this._selectedAnchors.indexOf(anchor) === -1) {\n      //if it isn't already selected...\n      if (!_SHIFT) {\n        this._selectedAnchors.length = 0;\n      }\n\n      this._selectedAnchors.push(anchor);\n    } else if (_SHIFT) {\n      this._selectedAnchors.splice(this._selectedAnchors.indexOf(anchor), 1);\n\n      anchor._draggable.endDrag();\n    }\n\n    _editingAxis.x = anchor.segment[anchor.i];\n    _editingAxis.y = anchor.segment[anchor.i + 1];\n\n    this._updateAnchors();\n\n    _callback(\"onPress\", this);\n  };\n\n  _proto3._deleteSelectedAnchors = function _deleteSelectedAnchors() {\n    var anchors = this._selectedAnchors,\n        i = anchors.length,\n        anchor,\n        index,\n        j,\n        jIndex;\n\n    while (--i > -1) {\n      anchor = anchors[i];\n      anchor.element.parentNode.removeChild(anchor.element);\n\n      anchor._draggable.enabled(false);\n\n      index = anchor.i;\n      jIndex = anchor.j;\n\n      if (!index) {\n        //first\n        anchor.segment.splice(index, 6);\n      } else if (index < anchor.segment.length - 2) {\n        anchor.segment.splice(index - 2, 6);\n      } else {\n        //last\n        anchor.segment.splice(index - 4, 6);\n      }\n\n      anchors.splice(i, 1);\n\n      this._anchors.splice(this._anchors.indexOf(anchor), 1);\n\n      for (j = 0; j < this._anchors.length; j++) {\n        if (this._anchors[j].i >= index && this._anchors[j].j === jIndex) {\n          this._anchors[j].i -= 6;\n        }\n      }\n    }\n\n    this._updateAnchors();\n\n    this.update();\n\n    this._saveState();\n\n    if (this.vars.onDeleteAnchor) {\n      this.vars.onDeleteAnchor.call(this.vars.callbackScope || this);\n    }\n  };\n\n  _proto3._onClickAnchor = function _onClickAnchor(anchor) {\n    var i = anchor.i,\n        segment = anchor.segment,\n        pi = anchor.isClosedStart ? segment.length - 4 : i - 2,\n        rnd = 1000,\n        isEnd = !i || i >= segment.length - 2,\n        angle1,\n        angle2,\n        length1,\n        length2,\n        sin,\n        cos;\n\n    if (_ALT && _recentlyAddedAnchor !== anchor && this._editingAnchor) {\n      anchor.smooth = !anchor.smooth;\n\n      if (isEnd && !anchor.isClosedStart) {\n        //the very ends can't be \"smooth\"\n        anchor.smooth = false;\n      }\n\n      anchor.element.setAttribute(\"d\", anchor.smooth ? this._circleHandle : this._squareHandle);\n\n      if (anchor.smooth && (!isEnd || anchor.isClosedStart)) {\n        angle1 = Math.atan2(segment[i + 1] - segment[pi + 1], segment[i] - segment[pi]);\n        angle2 = Math.atan2(segment[i + 3] - segment[i + 1], segment[i + 2] - segment[i]);\n        angle1 = (angle1 + angle2) / 2;\n        length1 = _getLength(segment, pi, i);\n        length2 = _getLength(segment, i, i + 2);\n\n        if (length1 < 0.2) {\n          length1 = _getLength(segment, i, pi - 4) / 4;\n          angle1 = angle2 || Math.atan2(segment[i + 7] - segment[pi - 3], segment[i + 6] - segment[pi - 4]);\n        }\n\n        if (length2 < 0.2) {\n          length2 = _getLength(segment, i, i + 6) / 4;\n          angle2 = angle1 || Math.atan2(segment[i + 7] - segment[pi - 3], segment[i + 6] - segment[pi - 4]);\n        }\n\n        sin = Math.sin(angle1);\n        cos = Math.cos(angle1);\n\n        if (Math.abs(angle2 - angle1) < Math.PI / 2) {\n          sin = -sin;\n          cos = -cos;\n        }\n\n        segment[pi] = ((segment[i] + cos * length1) * rnd | 0) / rnd;\n        segment[pi + 1] = ((segment[i + 1] + sin * length1) * rnd | 0) / rnd;\n        segment[i + 2] = ((segment[i] - cos * length2) * rnd | 0) / rnd;\n        segment[i + 3] = ((segment[i + 1] - sin * length2) * rnd | 0) / rnd;\n\n        this._updateAnchors();\n\n        this.update();\n\n        this._saveState();\n      } else if (!anchor.smooth && (!isEnd || anchor.isClosedStart)) {\n        if (i || anchor.isClosedStart) {\n          segment[pi] = segment[i];\n          segment[pi + 1] = segment[i + 1];\n        }\n\n        if (i < segment.length - 2) {\n          segment[i + 2] = segment[i];\n          segment[i + 3] = segment[i + 1];\n        }\n\n        this._updateAnchors();\n\n        this.update();\n\n        this._saveState();\n      }\n    } else if (!_SHIFT) {\n      this._selectedAnchors.length = 0;\n\n      this._selectedAnchors.push(anchor);\n    }\n\n    _recentlyAddedAnchor = null;\n\n    this._updateAnchors();\n  };\n\n  _proto3._updateAnchors = function _updateAnchors() {\n    var anchor = this._selectedAnchors.length === 1 ? this._selectedAnchors[0] : null,\n        segment = anchor ? anchor.segment : null,\n        i,\n        x,\n        y;\n    this._editingAnchor = anchor;\n\n    for (i = 0; i < this._anchors.length; i++) {\n      this._anchors[i].element.style.fill = this._selectedAnchors.indexOf(this._anchors[i]) !== -1 ? _selectionColor : \"white\"; //this._anchors[i].element.setAttribute(\"fill\", (this._selectedAnchors.indexOf(this._anchors[i]) !== -1) ? _selectionColor : \"white\");\n    }\n\n    if (anchor) {\n      this._handle1.setAttribute(\"d\", anchor.smooth ? this._circleHandle : this._squareHandle);\n\n      this._handle2.setAttribute(\"d\", anchor.smooth ? this._circleHandle : this._squareHandle);\n    }\n\n    i = anchor ? anchor.i : 0;\n\n    if (anchor && (i || anchor.isClosedStart)) {\n      x = anchor.isClosedStart ? segment[segment.length - 4] : segment[i - 2];\n      y = anchor.isClosedStart ? segment[segment.length - 3] : segment[i - 1]; //TODO: if they equal the anchor coordinates, just hide it.\n\n      this._handle1.style.visibility = this._line1.style.visibility = !_ALT && x === segment[i] && y === segment[i + 1] ? \"hidden\" : \"visible\";\n\n      this._handle1.setAttribute(\"transform\", \"translate(\" + x + _comma + y + \")\");\n\n      this._line1.setAttribute(\"points\", x + _comma + y + _comma + segment[i] + _comma + segment[i + 1]);\n    } else {\n      this._handle1.style.visibility = this._line1.style.visibility = \"hidden\";\n    }\n\n    if (anchor && i < segment.length - 2) {\n      x = segment[i + 2];\n      y = segment[i + 3];\n      this._handle2.style.visibility = this._line2.style.visibility = !_ALT && x === segment[i] && y === segment[i + 1] ? \"hidden\" : \"visible\";\n\n      this._handle2.setAttribute(\"transform\", \"translate(\" + x + _comma + y + \")\");\n\n      this._line2.setAttribute(\"points\", segment[i] + _comma + segment[i + 1] + _comma + x + _comma + y);\n    } else {\n      this._handle2.style.visibility = this._line2.style.visibility = \"hidden\";\n    }\n  };\n\n  _proto3._onPressAlt = function _onPressAlt() {\n    var anchor = this._editingAnchor;\n\n    if (anchor) {\n      if (anchor.i || anchor.isClosedStart) {\n        this._handle1.style.visibility = this._line1.style.visibility = \"visible\";\n      }\n\n      if (anchor.i < anchor.segment.length - 2) {\n        this._handle2.style.visibility = this._line2.style.visibility = \"visible\";\n      }\n    }\n  };\n\n  _proto3._onReleaseAlt = function _onReleaseAlt() {\n    var anchor = this._editingAnchor,\n        s,\n        i,\n        pi;\n\n    if (anchor) {\n      s = anchor.segment;\n      i = anchor.i;\n      pi = anchor.isClosedStart ? s.length - 4 : i - 2;\n\n      if (s[i] === s[pi] && s[i + 1] === s[pi + 1]) {\n        this._handle1.style.visibility = this._line1.style.visibility = \"hidden\";\n      }\n\n      if (s[i] === s[i + 2] && s[i + 1] === s[i + 3]) {\n        this._handle2.style.visibility = this._line2.style.visibility = \"hidden\";\n      }\n    }\n  };\n\n  _proto3._onPressHandle1 = function _onPressHandle1() {\n    if (this._editingAnchor.smooth) {\n      this._oppositeHandleLength = _getLength(this._editingAnchor.segment, this._editingAnchor.i, this._editingAnchor.i + 2);\n    }\n\n    _callback(\"onPress\", this);\n  };\n\n  _proto3._onPressHandle2 = function _onPressHandle2() {\n    if (this._editingAnchor.smooth) {\n      this._oppositeHandleLength = _getLength(this._editingAnchor.segment, this._editingAnchor.isClosedStart ? this._editingAnchor.segment.length - 4 : this._editingAnchor.i - 2, this._editingAnchor.i);\n    }\n\n    _callback(\"onPress\", this);\n  };\n\n  _proto3._onReleaseHandle = function _onReleaseHandle(e) {\n    this._onRelease(e);\n\n    this._saveState();\n  };\n\n  _proto3._onDragHandle1 = function _onDragHandle1() {\n    var anchor = this._editingAnchor,\n        s = anchor.segment,\n        i = anchor.i,\n        pi = anchor.isClosedStart ? s.length - 4 : i - 2,\n        rnd = 1000,\n        x = this._handle1._draggable.x,\n        y = this._handle1._draggable.y,\n        angle;\n    s[pi] = x = (x * rnd | 0) / rnd;\n    s[pi + 1] = y = (y * rnd | 0) / rnd;\n\n    if (anchor.smooth) {\n      if (_ALT) {\n        anchor.smooth = false;\n        anchor.element.setAttribute(\"d\", this._squareHandle);\n\n        this._handle1.setAttribute(\"d\", this._squareHandle);\n\n        this._handle2.setAttribute(\"d\", this._squareHandle);\n      } else {\n        angle = Math.atan2(s[i + 1] - y, s[i] - x);\n        x = this._oppositeHandleLength * Math.cos(angle);\n        y = this._oppositeHandleLength * Math.sin(angle);\n        s[i + 2] = ((s[i] + x) * rnd | 0) / rnd;\n        s[i + 3] = ((s[i + 1] + y) * rnd | 0) / rnd;\n      }\n    }\n\n    this.update();\n  };\n\n  _proto3._onDragHandle2 = function _onDragHandle2() {\n    var anchor = this._editingAnchor,\n        s = anchor.segment,\n        i = anchor.i,\n        pi = anchor.isClosedStart ? s.length - 4 : i - 2,\n        rnd = 1000,\n        x = this._handle2._draggable.x,\n        y = this._handle2._draggable.y,\n        angle;\n    s[i + 2] = x = (x * rnd | 0) / rnd;\n    s[i + 3] = y = (y * rnd | 0) / rnd;\n\n    if (anchor.smooth) {\n      if (_ALT) {\n        anchor.smooth = false;\n        anchor.element.setAttribute(\"d\", this._squareHandle);\n\n        this._handle1.setAttribute(\"d\", this._squareHandle);\n\n        this._handle2.setAttribute(\"d\", this._squareHandle);\n      } else {\n        angle = Math.atan2(s[i + 1] - y, s[i] - x);\n        x = this._oppositeHandleLength * Math.cos(angle);\n        y = this._oppositeHandleLength * Math.sin(angle);\n        s[pi] = ((s[i] + x) * rnd | 0) / rnd;\n        s[pi + 1] = ((s[i + 1] + y) * rnd | 0) / rnd;\n      }\n    }\n\n    this.update();\n  };\n\n  _proto3._onDragAnchor = function _onDragAnchor(anchor, changeX, changeY) {\n    var anchors = this._selectedAnchors,\n        l = anchors.length,\n        rnd = 1000,\n        i,\n        j,\n        s,\n        a,\n        pi;\n\n    for (j = 0; j < l; j++) {\n      a = anchors[j];\n      i = a.i;\n      s = a.segment;\n\n      if (i) {\n        s[i - 2] = ((s[i - 2] + changeX) * rnd | 0) / rnd;\n        s[i - 1] = ((s[i - 1] + changeY) * rnd | 0) / rnd;\n      } else if (a.isClosedStart) {\n        pi = s.length - 2;\n        s[pi] = _round(s[pi] + changeX);\n        s[pi + 1] = _round(s[pi + 1] + changeY);\n        s[pi - 2] = _round(s[pi - 2] + changeX);\n        s[pi - 1] = _round(s[pi - 1] + changeY);\n      }\n\n      s[i] = ((s[i] + changeX) * rnd | 0) / rnd;\n      s[i + 1] = ((s[i + 1] + changeY) * rnd | 0) / rnd;\n\n      if (i < s.length - 2) {\n        s[i + 2] = ((s[i + 2] + changeX) * rnd | 0) / rnd;\n        s[i + 3] = ((s[i + 3] + changeY) * rnd | 0) / rnd;\n      }\n\n      if (a !== anchor) {\n        a.element.setAttribute(\"transform\", \"translate(\" + s[i] + _comma + s[i + 1] + \")\");\n      }\n    }\n\n    this.update();\n  };\n\n  _proto3.enabled = function enabled(_enabled2) {\n    if (!arguments.length) {\n      return this._enabled;\n    }\n\n    var i = this._anchors.length;\n\n    while (--i > -1) {\n      this._anchors[i]._draggable.enabled(_enabled2);\n    }\n\n    this._enabled = _enabled2;\n\n    this._handle1._draggable.enabled(_enabled2);\n\n    this._handle2._draggable.enabled(_enabled2);\n\n    if (this._draggable) {\n      this._draggable.enabled(_enabled2);\n    }\n\n    if (!_enabled2) {\n      this.deselect();\n      this._selectionHittest.parentNode && this._selectionHittest.parentNode.removeChild(this._selectionHittest);\n      this._selection.parentNode && this._selection.parentNode.removeChild(this._selection);\n    } else if (!this._selection.parentNode) {\n      this.path.ownerSVGElement.appendChild(this._selectionHittest);\n      this.path.ownerSVGElement.appendChild(this._selection);\n      this.init();\n\n      this._saveState();\n    }\n\n    this._updateAnchors();\n\n    return this.update();\n  };\n\n  _proto3.update = function update(readPath) {\n    var d = \"\",\n        anchor = this._editingAnchor,\n        i,\n        s,\n        x,\n        y,\n        pi;\n\n    if (readPath) {\n      this.init();\n    }\n\n    if (anchor) {\n      i = anchor.i;\n      s = anchor.segment;\n\n      if (i || anchor.isClosedStart) {\n        pi = anchor.isClosedStart ? s.length - 4 : i - 2;\n        x = s[pi];\n        y = s[pi + 1];\n\n        this._handle1.setAttribute(\"transform\", \"translate(\" + x + _comma + y + \")\");\n\n        this._line1.setAttribute(\"points\", x + _comma + y + _comma + s[i] + _comma + s[i + 1]);\n      }\n\n      if (i < s.length - 2) {\n        x = s[i + 2];\n        y = s[i + 3];\n\n        this._handle2.setAttribute(\"transform\", \"translate(\" + x + _comma + y + \")\");\n\n        this._line2.setAttribute(\"points\", s[i] + _comma + s[i + 1] + _comma + x + _comma + y);\n      }\n    }\n\n    if (readPath) {\n      d = this.path.getAttribute(\"d\");\n    } else {\n      for (i = 0; i < this._rawPath.length; i++) {\n        s = this._rawPath[i];\n\n        if (s.length > 7) {\n          d += \"M\" + s[0] + _comma + s[1] + \"C\" + s.slice(2).join(_comma);\n        }\n      }\n\n      this.path.setAttribute(\"d\", d);\n\n      this._selectionPath.setAttribute(\"d\", d);\n\n      this._selectionHittest.setAttribute(\"d\", d);\n    }\n\n    if (this.vars.onUpdate && this._enabled) {\n      _callback(\"onUpdate\", this, d);\n    }\n\n    return this;\n  };\n\n  _proto3.getRawPath = function getRawPath(applyTransforms, offsetX, offsetY) {\n    if (applyTransforms) {\n      var m = _getConsolidatedMatrix(this.path);\n\n      return transformRawPath(copyRawPath(this._rawPath), 1, 0, 0, 1, m.e + (offsetX || 0), m.f + (offsetY || 0));\n    }\n\n    return this._rawPath;\n  };\n\n  _proto3.getString = function getString(applyTransforms, offsetX, offsetY) {\n    if (applyTransforms) {\n      var m = _getConsolidatedMatrix(this.path);\n\n      return rawPathToString(transformRawPath(copyRawPath(this._rawPath), 1, 0, 0, 1, m.e + (offsetX || 0), m.f + (offsetY || 0)));\n    }\n\n    return this.path.getAttribute(\"d\");\n  };\n\n  _proto3.getNormalizedSVG = function getNormalizedSVG(height, originY, shorten, onEaseError) {\n    var s = this._rawPath[0],\n        tx = s[0] * -1,\n        ty = originY === 0 ? 0 : -(originY || s[1]),\n        l = s.length,\n        sx = 1 / (s[l - 2] + tx),\n        sy = -height || s[l - 1] + ty,\n        rnd = 1000,\n        points,\n        i,\n        x1,\n        y1,\n        x2,\n        y2;\n    _temp.length = 0;\n\n    if (sy) {\n      //typically y ends at 1 (so that the end values are reached)\n      sy = 1 / sy;\n    } else {\n      //in case the ease returns to its beginning value, scale everything proportionally\n      sy = -sx;\n    }\n\n    sx *= rnd;\n    sy *= rnd;\n\n    for (i = 0; i < l; i += 2) {\n      _temp[i] = ((s[i] + tx) * sx | 0) / rnd;\n      _temp[i + 1] = ((s[i + 1] + ty) * sy | 0) / rnd;\n    }\n\n    if (onEaseError) {\n      points = [];\n      l = _temp.length;\n\n      for (i = 2; i < l; i += 6) {\n        x1 = _temp[i - 2];\n        y1 = _temp[i - 1];\n        x2 = _temp[i + 4];\n        y2 = _temp[i + 5];\n        points.push(x1, y1, x2, y2);\n        bezierToPoints(x1, y1, _temp[i], _temp[i + 1], _temp[i + 2], _temp[i + 3], x2, y2, 0.001, points, points.length - 2);\n      }\n\n      x1 = points[0];\n      l = points.length;\n\n      for (i = 2; i < l; i += 2) {\n        x2 = points[i];\n\n        if (x2 < x1 || x2 > 1 || x2 < 0) {\n          onEaseError();\n          break;\n        }\n\n        x1 = x2;\n      }\n    }\n\n    if (shorten && l === 8 && _temp[0] === 0 && _temp[1] === 0 && _temp[l - 2] === 1 && _temp[l - 1] === 1) {\n      return _temp.slice(2, 6).join(\",\");\n    }\n\n    _temp[2] = \"C\" + _temp[2];\n    return \"M\" + _temp.join(\",\");\n  };\n\n  _proto3.kill = function kill() {\n    this.enabled(false);\n    this._g.parentNode && this._g.parentNode.removeChild(this._g);\n  };\n\n  _proto3.revert = function revert() {\n    this.kill();\n  };\n\n  return PathEditor;\n}();\nPathEditor.simplifyPoints = simplifyPoints;\nPathEditor.pointsToSegment = pointsToSegment;\n\nPathEditor.simplifySVG = function (data, vars) {\n  //takes a <path> element or data string and simplifies it according to whatever tolerance you set (default:1, the bigger the number the more variance there can be). vars: {tolerance:1, cornerThreshold:degrees, curved:true}\n  var element, points, i, x1, x2, y1, y2, bezier, precision, tolerance, l, cornerThreshold;\n  vars = vars || {};\n  tolerance = vars.tolerance || 1;\n  precision = vars.precision || 1 / tolerance;\n  cornerThreshold = (vars.cornerThreshold === undefined ? 18 : +vars.cornerThreshold) * _DEG2RAD;\n\n  if (typeof data !== \"string\") {\n    //element\n    element = data;\n    data = element.getAttribute(\"d\");\n  }\n\n  if (data.charAt(0) === \"#\" || data.charAt(0) === \".\") {\n    //selector text\n    element = _doc.querySelector(data);\n\n    if (element) {\n      data = element.getAttribute(\"d\");\n    }\n  }\n\n  points = vars.curved === false && !/[achqstvz]/ig.test(data) ? data.match(_numbersExp) : stringToRawPath(data)[0];\n\n  if (vars.curved !== false) {\n    bezier = points;\n    points = [];\n    l = bezier.length;\n\n    for (i = 2; i < l; i += 6) {\n      x1 = +bezier[i - 2];\n      y1 = +bezier[i - 1];\n      x2 = +bezier[i + 4];\n      y2 = +bezier[i + 5];\n      points.push(_round(x1), _round(y1), _round(x2), _round(y2));\n      bezierToPoints(x1, y1, +bezier[i], +bezier[i + 1], +bezier[i + 2], +bezier[i + 3], x2, y2, 1 / (precision * 200000), points, points.length - 2);\n    }\n\n    points = pointsToSegment(simplifyPoints(points, tolerance), vars.curviness, cornerThreshold);\n    points[2] = \"C\" + points[2];\n  } else {\n    points = simplifyPoints(points, tolerance);\n  }\n\n  data = \"M\" + points.join(\",\");\n\n  if (element) {\n    element.setAttribute(\"d\", data);\n  }\n\n  return data;\n};\n\nPathEditor.create = function (target, vars) {\n  return new PathEditor(target, vars);\n};\n\nPathEditor.editingAxis = _editingAxis;\n\nPathEditor.getSnapFunction = function (vars) {\n  //{gridSize, radius, x, y, width, height}\n  var r = vars.radius || 2,\n      big = 1e20,\n      minX = vars.x || vars.x === 0 ? vars.x : vars.width ? 0 : -big,\n      minY = vars.y || vars.y === 0 ? vars.y : vars.height ? 0 : -big,\n      maxX = minX + (vars.width || big * big),\n      maxY = minY + (vars.height || big * big),\n      containX = vars.containX !== false,\n      containY = vars.containY !== false,\n      axis = vars.axis,\n      grid = vars.gridSize;\n  r *= r;\n  return function (p) {\n    var x = p.x,\n        y = p.y,\n        gridX,\n        gridY,\n        dx,\n        dy;\n\n    if (containX && x < minX || (dx = x - minX) * dx < r) {\n      x = minX;\n    } else if (containX && x > maxX || (dx = maxX - x) * dx < r) {\n      x = maxX;\n    }\n\n    if (containY && y < minY || (dy = y - minY) * dy < r) {\n      y = minY;\n    } else if (containY && y > maxY || (dy = maxY - y) * dy < r) {\n      y = maxY;\n    }\n\n    if (axis) {\n      dx = x - axis.x;\n      dy = y - axis.y;\n\n      if (dx * dx < r) {\n        x = axis.x;\n      }\n\n      if (dy * dy < r) {\n        y = axis.y;\n      }\n    }\n\n    if (grid) {\n      gridX = minX + Math.round((x - minX) / grid) * grid; //closest grid slot on x-axis\n\n      dx = gridX - x;\n      gridY = minY + Math.round((y - minY) / grid) * grid; //closest grid slot on y-axis\n\n      dy = gridY - y;\n\n      if (dx * dx + dy * dy < r) {\n        x = gridX;\n        y = gridY;\n      }\n    }\n\n    p.x = x;\n    p.y = y;\n  };\n};\n\nPathEditor.version = \"3.13.0\";\nPathEditor.register = _initCore;\nexport { PathEditor as default };",
      "start": 1746891116387,
      "end": 1746891116982,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1746891116982,
      "end": 1746891116982,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1746891116982,
      "end": 1746891116982,
      "order": "pre"
    },
    {
      "name": "unplugin-vue-i18n",
      "start": 1746891116982,
      "end": 1746891116982,
      "order": "pre"
    },
    {
      "name": "nuxtjs:i18n-macros-transform",
      "start": 1746891116982,
      "end": 1746891116982,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1746891116982,
      "end": 1746891116982,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1746891116982,
      "end": 1746891116982,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1746891116982,
      "end": 1746891116982,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1746891116982,
      "end": 1746891116982,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1746891116982,
      "end": 1746891116982,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1746891116982,
      "end": 1746891116982,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1746891116982,
      "end": 1746891116982,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1746891116982,
      "end": 1746891116982,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1746891116982,
      "end": 1746891116982,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1746891116982,
      "end": 1746891116982,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1746891116982,
      "end": 1746891116982,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1746891116982,
      "end": 1746891116983,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1746891116983,
      "end": 1746891116983,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1746891116983,
      "end": 1746891116983,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1746891116983,
      "end": 1746891116983,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1746891116983,
      "end": 1746891116983,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1746891116983,
      "end": 1746891116983,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1746891116983,
      "end": 1746891116983,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1746891116983,
      "end": 1746891116996,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1746891116996,
      "end": 1746891116996,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1746891116996,
      "end": 1746891116996,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1746891116996,
      "end": 1746891116997,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-resource",
      "start": 1746891116997,
      "end": 1746891116997,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-meta-deprecation",
      "start": 1746891116997,
      "end": 1746891116997,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1746891116997,
      "end": 1746891116997,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1746891116997,
      "end": 1746891116997,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1746891116997,
      "end": 1746891116997,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1746891116997,
      "end": 1746891116997,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1746891116997,
      "end": 1746891116997,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1746891116997,
      "end": 1746891116997,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1746891116997,
      "end": 1746891116998,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1746891116998,
      "end": 1746891116998,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1746891116998,
      "end": 1746891116998,
      "order": "normal"
    }
  ]
}
